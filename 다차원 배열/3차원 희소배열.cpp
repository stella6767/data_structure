//#include <iostream>
//using namespace std;
//
//class arrInt3 {
//public:
//    arrInt3(); //생성자 선언
//    int GetAt(int p1, int p2, int p3);
//    void SetAt(int p1, int p2, int p3, int v);
//private:
//    int arr_[100]; //100개 1차원 배열으로 마치 3차원 배열이 있는 것처럼 표현할 수 있다. //실제로 25개의 데이터만 표현가능
//    int size_; //기억되는 정수 크기
//    int used_; // 현재 저장된 데이터의 크기
//};
//
//
//arrInt3::arrInt3() {
//	 size_ = 50;  //50까지 가능하니까 실제로 3차원으로 표현할 수 있는 데이터 개수는 12개 
//	 used_ = 0; //현재 크기 초기화
//
//	 //arr_[100]= { 0, };
//	
//};
//
//int arrInt3::GetAt(int p1,int p2,int p3) {
//		if (p1>100||p2>100||p3>100) //출력시 범위를 벗어나는 입력에 대해서는 -1출력
//	{
//		return -1;
//	}
//		
//		for (int i = 0; i < used_; i++) { //50번 반복해서 번지 값 찾음음
//		if ((arr_[i * 4] == p1) && (arr_[i * 4 + 1] == p2) && (arr_[i * 4 + 2] == p3)) return arr_[i * 4 + 3];
//	}
//	return 0; 
//	
//
//
//};
//
//void arrInt3::SetAt(int p1, int p2,int p3,int v) {
//
//	if (used_ == size_) return; //이미 데이터가 저장 가능 최대크기만큼 차 있으면 되돌림
//
//	//1,1,1,1 이라면
//	arr_[used_ * 4 ]= p1; //0번지에 1   다음 건수는 사이즈가 하나씩 증가해서 4번지부터
//	arr_[used_ * 4 + 1 ]= p2; //1번지에 1   이렇게 100개의 공간
//	arr_[used_ * 4 + 2 ]= p3; //2번지에 1
//	arr_[used_ * 4 + 3 ]= v; //3 번지에 1  마치 [1[1[1 =1 
// 	used_++; // 50만큼 간다.
//
//};
//
//
//
//
//
//int main() {
//	arrInt3 cube;
//	int x, y, z, v;
//
//	for (int i = 0; i < 3; i++) {
//		cin >> x >> y >> z >> v;
//		cube.SetAt(x, y, z, v);
//	}
//
//	cin >> x >> y >> z;
//	cout << cube.GetAt(x, y, z); //[x[y[z = 에는 무슨 값이 있는지 알아내는 건데 실제로 3차원 배열 사이즈만큼 배분하지 않고
//	//적은 사이즈의 배열에 마치 있는 것처럼 이렇게 표현할 수 있다. 메모맂 절약을 위해서
//}
//
////다음의 클래스 선언을 
////활용하여 100*100*100의 양의정수를 위한 희소행렬을 구하시오. 단, 기억되는 정수는 최대 50개이다.
////이때 입력의 색인(index)이 배열의 범위를 벗어나거나, 입력값이 0보다 작거나 같으면, 배열에 저장하지 않는다.
////또한, 출력시 범위를 넘어서는 입력에 대해서는 - 1을 출력하고 입력되지 않은 셀에 대해서는 0을 출력한다.